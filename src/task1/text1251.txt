Введение ВведениеВведениеВведение
в Java 7
В этой главе:
??Java как платформа и как язык;
??небольшие, но мощные синтаксические изменения;
??оператор try-with-resources;
??усовершенствованная обработка исключений.
Добро пожаловать в Java 7. Положение дел в этом языке может показаться вам немного непривычным. И это хорошо — так много всего предстоит исследовать теперь, когда шумиха вокруг новой версии утихла и Java 7 раскочегарился на полную мощность. Дочитав эту книгу, вы сделаете только первые шаги в огромный мир — мир новых функций, софтверного искусства, а также в мир других языков, действующих на виртуальной машине Java (JVM).
В качестве разминки мы плавно введем вас в курс Java 7, но уже на этом этапе познакомим вас с некоторыми мощными возможностями. Для начала объясним отличие, которое зачастую неправильно понимается: поговорим об отличиях языка и платформы.
Затем мы рассмотрим проект «Монета» — набор небольших, но эффективных нововведений, появившихся в Java 7. Мы расскажем, как построен процесс одобрения, внедрения и выпуска изменений на платформе Java. Обсудив этот процесс, мы перейдем к рассмотрению шести основных новых функций, появившихся в рамках проекта «Монета».
Вы изучите новый синтаксис, в частности новый способ обработки исключений (множественный catch), а также работу с конструкцией try-with-resources (использование ресурсов в блоке try). Эта конструкция помогает избегать ошибок в коде, работающем с файлами или другими ресурсами. Дочитав эту главу, вы сможете по-новому писать на Java и будете в полной боевой готовности для изучения масштабных тем, ожидающих впереди.
Итак, приступим к делу и поговорим о дуализме языка и платформы — пожалуй, это центральный аспект современного языка ? ? ? ? ? ? -Java? -. Это важнейший вопрос, к которому мы многократно будем возвращаться на протяжении всей книги, поэтому с ним просто необходимо разобраться.
42 Часть 1. Разработка на Java 7
1.1. Язык и платформа
Важнейшая проблема, с которой мы начнем наш разговор, — это разница между языком ? ? ? ? ? ? ? ? ? -? ? - Java?и платформой Java? -. Удивительно, но разные авторы по-разному определяют и феномен языка, и феномен платформы. Из-за этого может возникать неясность и некоторая путаница и в том, чем отличаются язык и платформа, и в том, к чему относятся те или иные программные функции, используемые в коде приложения.
Четко очертим эти различия прямо сейчас, так как эта разница затрагивает суть самых разных тем из нашей книги. Итак, вот эти определения.
??Язык Java — это статически типизированный объектно-ориентированный язык, над которым мы немного пошутили в разделе «Об этой книге». Надеемся, что вы уже довольно хорошо знакомы с ним. Одно из самых очевидных качеств языка Java заключается в том, что он пригоден для чтения человеком (или, по крайней мере, должен таким быть!).
??Платформа Java — это программное обеспечение, предоставляющее нам среду времени исполнения. Это виртуальная машина Java (JVM), линкующая и выполняющая ваш код в том виде, в каком он ей предоставляется. Код предоставляется в виде файлов классов, непригодных для чтения человеком. Иными словами, машина не интерпретирует непосредственно файлы с исходным кодом на языке Java, а требует предварительного преобразования этого кода в файлы классов.
Одна из основных причин успеха ? ? ? ? ? ? ? ? - Java?как системы ПО заключается в ее стандартизации. Это означает, что ? ? ? ? ? ? - Java?имеет спецификации, описывающие, как должна работать платформа. Стандартизация позволяет различным производителям и участникам разнообразных проектов создавать реализации, которые теоретически должны работать одинаково. Такие спецификации не гарантируют, насколько высока будет производительность конкретной реализации одной конкретной задачи, но вполне гарантируют правильность результатов.
Существует несколько отдельных спецификаций, управляющих системой Java. Самые важные из них — это спецификация языка ? ? ? ? ? - Java?(? JLS? -) и спецификация виртуальной машины Java (VMSpec). В версии Java 7 это разделение соблюдается очень строго; на самом деле VMSpec уже нигде не ссылается на JLS. Если вы усматриваете в этом признак того, насколько серьезно в Java 7 поставлена работа с исходными языками, не являющимися Java, то нам нравится ход ваших мыслей, продолжайте в том же духе. Ниже мы подробнее обсудим разницу между двумя этими спецификациями.
При внимательном изучении такого дуализма напрашивается вопрос: «А какова же связь между языком и платформой?» Если в Java 7 они настолько разделены, то как они стыкуются и образуют общую систему Java?
Связь между языком и платформой заключается в совместном использовании файлов классов (файлов в формате .class). Рекомендуем серьезно изучить определение файлов классов. Эти сведения вам точно не помешают, а знание этой темы — один из способов, позволяющих хорошему ? -? ? ? -Java---программисту стать выдающимся. На рис. 1.1 показан полный процесс создания и использования кода Java.
Глава 1. Введение в Java 7
43
Рис. 1.1. Исходный код Java преобразуется в файлы .class,
затем с ним производятся манипуляции в период загрузки,
после чего он подвергается динамической компиляции
Как понятно из рисунка, код Java начинается в виде исходного кода, написанного программистом и пригодного для чтения человеком. После этого javac компилирует его в файл .class. Затем эта информация загружается в виртуальную машину Java. Обратите внимание, что манипуляции с классами и их изменение зачастую осуществляются в ходе процесса загрузки. Многие популярные фреймворки (особенно те, в названии которых присутствует слово Enterprise) преобразуют классы в ходе загрузки.
JAVA — ЭТО КОМПИЛИРУЕМЫЙ
ИЛИ ИНТЕРПРЕТИРУЕМЫЙ ЯЗЫК?
Обычно Java видится разработчику как язык, компилируемый в файлы .class до того, как код будет использоваться на JVM. Призадумавшись, многие разработчики также объясняют, что работа байт-кода начинается с интерпретации виртуальной машиной JVM, но несколько позже код также проходит динамическую компиляцию (JIT). Но на этом многие специалисты начинают «плыть», выстраивая несколько надуманную концепцию о том, что байт-код, в сущности, является машинным кодом для воображаемого или упрощенного процессора.
На самом деле байт-код виртуальной машины Java можно считать переходной формой между исходным кодом, пригодным для чтения человеком, и машинным кодом. В техническом отношении с точки зрения теории компиляции байт-код — это действительно своеобразный промежуточный язык (intermediate language), а не настоящий машинный код. Это означает, что процесс преобразования исходного кода Java в байт-код не является компиляцией в том смысле, в каком она понимается в языках C и С++. В свою очередь, javac не назовешь таким же компилятором, как gcc. В сущности, это генератор файлов классов для обработки исходного кода Java. Настоящим компилятором в экосистеме Java является динамический компилятор (JIT) (см. рис. 1.1).
Некоторые специалисты характеризуют систему Java как «динамически компилируемую». При этом акцентируется тот факт, что истинная компиляция — это динамическая компиляция во время исполнения, а не создание файла класса во время исполнения.
Поэтому верным ответом на вопрос «Java — это компилируемый или интерпретируемый язык?» будет: «И такой и такой».
44 Часть 1. Разработка на Java 7
Итак, когда мы немного разъяснили разницу между языком и платформой, поговорим о некоторых заметных изменениях синтаксиса языка, появившихся в Java 7. Начнем с небольших синтаксических перемен, объединенных в рамках проекта «Монета».
1.2. Малое прекрасно — расширения языка Java, или Проект «Монета»
Проект «Монета» (? ? ? ? ? ? ? ? - Project?Coin? -) — это свободный проект, разрабатываемый в рамках подготовки ? ? ? ? ? ? ? ? ? ? ? -Java ? 7 (и 8) с 2009 года. В этом разделе мы объясним, как подбирались функции и как процесс эволюции языка происходит на уровне небольших изменений, объединенных проектом «Монета». Этот раздел будет построен в форме ситуационного исследования (case study).
ПРИЧЕМ ТУТ «МОНЕТА»
Цель проекта «Монета» — постепенно вносить в язык Java небольшие изменения. Это название в английском языке связано с игрой слов, так как существительное coin означает «монета», а глагол to coin — «чеканить». Это же слово может означать «выдумать», например «выдумать фразу». Именно в таком значении «Монета» понимается здесь — проект «чеканит» новые выражения, добавляя их в язык.
Подобные языковые игры, фантазии и вездесущие несносные каламбуры просто наводнили техническую культуру. Хотя вы, вероятно, к этому уже привыкли.
М
ы считаем, что важно рассказать не только о том, что изменилось в языке, но и о том, почему появилось такое изменение. В ходе разработки Java 7 вокруг новой версии языка творилось множество всего интересного. Но члены сообщества не всегда и не вполне представляли, сколько работы потребуется на полную разработку изменений — до такой степени готовности, чтобы их можно было показать людям. Мы надеемся, что сможем пролить немного света на эту проблему, а также развеять некоторые мифы. Но если вы не очень интересуетесь тем, как развивается язык Java, можете переходить к разделу 1.3 — там мы непосредственно обсуждаем конкретные изменения в языке.
В изменении языка ? ? ? ? ? ? - Java?прослеживается определенная кривая усилий. Реализация некоторых языковых деталей требует значительно меньшего количества разработок, чем реализация других. На рис. 1.2 мы попытались представить различные линии разработки и относительное количество усилий, требуемое в каждом конкретном случае. Мы расположили эти линии в порядке возрастания необходимых усилий.
В принципе, лучше идти по пути наименьшего сопротивления. Это означает, что если существует возможность реализовать новую функцию как библиотеку, то так и стоит поступить. Но не все функции настолько просты, чтобы их можно было реализовывать в виде библиотек либо новых возможностей интегрированной среды разработки. При реализации некоторые функции должны быть глубже укоренены в платформе.
Глава 1. Введение в Java 7 45
Некоторые функции языка называются выражением «синтаксический сахар» (syntactic sugar). Это означает, что такая синтаксическая форма избыточна — она уже есть в языке, — но синтаксический сахар существует потому, что человеку с ним легче работать.
Действует общее правило, согласно которому функции, являющиеся синтаксическим сахаром, удаляются из представления программы для компилятора на ранней стадии процесса компиляции. Принято говорить об «обессахаривании» кода для получения базового представления конкретной функции.
Внедрять в язык изменения на уровне синтаксического сахара сравнительно легко, так как для этого требуется выполнить небольшую работу. Изменения вносятся только на уровне компилятора (в случае с Java это javac).
Рис. 1.2. Относительная сложность усилий при реализации новой функциональности различными способами
Ниже перечислены функции (в основном из Java 7), которые иллюстрируют элементы приведенной выше шкалы:
??синтаксический сахар — символы подчеркивания в числах (Java 7);
??небольшая новая языковая функция — конструкция try-with-resources (Java 7);
??изменение формата файлов классов — аннотации (Java 5);
??новая функция виртуальной машины Java — invokedynamic (Java 7).
СИНТАКСИЧЕСКИЙ САХАР
Проект «Монета» (а также оставшаяся часть этой главы) посвящен переменам, расположенным в диапазоне от синтаксического сахара до небольших изменений языка.
Первая серия предложений по изменениям в рамках «Монеты» высказывалась на рассылке разработчиков «Монеты» в период с февраля по март 2009 года. Было внесено почти 70 предложений, демонстрирующих, насколько широк диапазон возможных оптимизаций. Было даже сделано шутливое предложение добавить многострочные строки в стиле «лолкотов» — юмористических надписей на фотографиях с котами, которые бывают смешными или немного издевательскими, — см. http://icanhascheezburger.com/.
46 Часть 1. Разработка на Java 7
Предложения «Монеты» оценивались в соответствии с совершенно простым набором правил. Автор предложения должен был сделать три вещи:
??подать подробное правильно оформленное предложение, описывающее предлагаемое изменение (принципиально это должно быть изменение языка Java, а не изменение виртуальной машины Java);
??открыто обсуждать сделанное предложение в рассылке и учитывать конструктивную критику от других участников;
??быть готовым предоставить прототипный набор заплаток (патчей), которые позволили бы реализовать предложенное изменение.
На примере проекта «Монета» хорошо видно, как язык и платформа могут развиваться в будущем: изменения обсуждаются открыто, происходит раннее прототипирование функций, работа ведется в коллективном режиме.
На данном этапе вы можете задать вопрос: «А как выглядит такое маленькое изменение в спецификации?» Одно из таких изменений, которое мы рассмотрим ниже, связано с добавлением единственного слова — String — в раздел 14.11 спецификации JLS. Сложно представить себе более мелкое изменение, но даже оно затрагивает сразу несколько частей спецификации.
JAVA 7 — ПЕРВАЯ ВЕРСИЯ, КОТОРАЯ РАЗРАБАТЫВАЛАСЬ
В СТИЛЕ СВОБОДНОГО ПО
Java не всегда был «свободным» языком программирования. Но после соответствующего объявления, сделанного на конференции JavaOne в 2006 году, исходный код языка Java был выпущен по лицензии GPLv2 (за исключением отдельных фрагментов, исходного кода которых у Sun не было). Это случилось примерно на этапе выхода Java 6, поэтому Java 7 — первая версия языка, которая разрабатывалась по лицензии свободного программного обеспечения (OSS). При создании платформы Java в свободном режиме основное внимание было приковано к проекту OpenJDK.
В рассылках, таких как coin-dev, lambda-dev и mlvm-dev, велись развернутые дискуссии о функциях, которые могут быть добавлены в будущем. Таким образом, широкое сообщество разработчиков могло совместно заниматься созданием Java 7. На самом деле мы помогаем вести программу Adopt OpenJDK, чтобы сориентировать других разработчиков, пока мало знакомых с OpenJDK, — так мы помогаем улучшать и сам язык Java. Посетите страницу http://java.net/projects/jugs/pages/AdoptOpenJDK, может быть, вы захотите к нам присоединиться.
Изменения всегда приводят к последствиям, которые потом сказываются на всей структуре языка.
Вот действия, которые следует осуществить (или как минимум проверить их необходимость) при любом изменении:
??обновить JLS;
??реализовать прототип в компиляторе исходного кода;
??добавить библиотечную поддержку, необходимую для данного изменения;
??написать тесты и примеры;
??обновить документацию.
Глава 1. Введение в Java 7 47
Кроме того, если изменение касается виртуальной машины или платформы, то следует:
??обновить спецификацию VMSpec;
??реализовать изменения виртуальной машины;
??добавить поддержку в файл класса и инструментарий виртуальной машины;
??учесть воздействие изменения на отражение (reflection);
??учесть воздействие изменения на сериализацию;
??обдумать любые воздействия на компоненты, работающие с нативным кодом, такие как нативный интерфейс Java (JNI).
Как видите, работы немало, и это уже после того, как будет учтено воздействие изменения на всю спецификацию языка!
Когда дело доходит до внесения изменений, особенно щекотливые ситуации возникают с системой типов. Не потому, что система типов в Java плоха. Дело в том, что языки с богатой системой статических типов обычно имеют множество возможных точек взаимодействия между различными компонентами таких систем типов. Поэтому любые изменения в системе типов могут приводить к неожиданным изменениям.
В рамках проекта «Монета» была избрана очень разумная стратегия решения таких проблем: участникам проекта рекомендуется не затрагивать систему типов при предложении изменений. Учитывая, какой объем работы требуется для внесения даже малейших изменений, такой подход оказался прагматичным.
Итак, мы немного познакомились с основами проекта «Монета», теперь рассмотрим отдельные функции, которые были отобраны для включения в язык.
1.3. Изменения в рамках
проекта «Монета»
В рамках проекта «Монета» в язык ? ? ? ? ? ? -Java ? 7 было добавлено шесть основных нововведений. Это строки (String) в конструкции switch, новые формы числовых литералов, усовершенствованная обработка исключений, применение ресурсов в блоке try (конструкция try-with-resources), ромбовидный синтаксис и исправление ситуации с предупреждениями, возникавшими при использовании функций с переменным количеством аргументов.
М
ы собираемся подробно обсудить эти изменения, сделанные в рамках проекта «Монета». Нам предстоит поговорить о синтаксисе и о значении новых функций. Кроме того, мы попытаемся, насколько это возможно, объяснить мотивы, по которым были приняты те или иные новые функции. Мы не будем приводить полные формальные обоснования этих предложений, но все эти материалы доступны в архиве расылки coin-dev. Поэтому, если вы молодой и перспективный разработчик языков программирования, то там можете подробно изучить все предложения.
Итак, поговорим о первой из новых функций Java 7 — строковых значениях String в конструкции switch.
48 Часть 1. Разработка на Java 7
1.3.1. Строки в конструкции switch
Оператор switch в Java позволяет писать эффективные многократно ветвящиеся инструкции без многих и многих уродливо вложенных друг в друга операторов if — вот так:
public void printDay(int dayOfWeek) {
switch (dayOfWeek) {
case 0: System.out.println("Sunday"); break;
case 1: System.out.println("Monday"); break;
case 2: System.out.println("Tuesday"); break;
case 3: System.out.println("Wednesday"); break;
case 4: System.out.println("Thursday"); break;
case 5: System.out.println("Friday"); break;
case 6: System.out.println("Saturday"); break;
default: System.err.println("Error!"); break;
}
}
В Java 6 и ниже значениями для условий могли быть только константы типов byte, char, short, int (или технически их эквивалентные ссылочные типы Byte, Character, Short, Integer) либо константы enum. В ? ? ? ? ? ? ? -Java ? 7 спецификация была расширена и к использованию был допущен тип String. В конце концов, это же константы.
public void printDay(String dayOfWeek) {
switch (dayOfWeek) {
case "Sunday": System.out.println("Dimanche"); break;
case "Monday": System.out.println("Lundi"); break;
case "Tuesday": System.out.println("Mardi"); break;
case "Wednesday": System.out.println("Mercredi"); break;
case "Thursday": System.out.println("Jeudi"); break;
case "Friday": System.out.println("Vendredi"); break;
case "Saturday": System.out.println("Samedi"); break;
default: System.out.println("Error: '"+ dayOfWeek
+"' is not a day of the week"); break;
}
}
Во всех других отношениях конструкция switch не изменилась. Как и многие другие изменения в рамках проекта «Монета», это совсем простые нововведения, которые, однако, значительно упрощают жизнь Java-программистам.
1.3.2. Усовершенствованный синтаксис для числовых литералов
Было сделано несколько самостоятельных предложений, касающихся нового синтаксиса целочисленных типов. В итоге приняты следующие положения:
??числовые константы (то есть любой из примитивных целочисленных типов) теперь могут выражаться в виде двоичных литералов;
Глава 1. Введение в Java 7 49
??в целочисленных константах могут использоваться нижние подчеркивания — они повышают удобочитаемость кода.
На первый взгляд оба изменения кажутся довольно неброскими. Но оба нововведения вызвали небольшое раздражение у Java-программистов.
Однако эти усовершенствования очень интересны для низкоуровневых программистов — тех, кто работает с «сырыми» сетевыми протоколами, шифрованием или занимается другими делами, предполагающими операции с битами. Итак, начнем с рассмотрения двоичных литералов.
Двоичные литералы
До выхода ? ? ? ? ? ? ? ? -Java ? 7, если вы хотели манипулировать двоичными значениями, приходилось либо пользоваться неуклюжим (и чреватым множеством ошибок) преобразованием к исходному типу (base conversion), либо задействовать методы parseX. Например, если вы хотите гарантировать, чтобы int x правильно представляло комбинацию битов для десятичного значения 102, напишите такое выражение:
int x = Integer.parseInt("1100110", 2);
Это слишком большое количество кода, если требуется просто гарантировать, что x в конечном итоге имеет правильную комбинацию битов. Несмотря на красивый вид этой записи, такой подход связан с некоторыми проблемами.
??Очень много текста.
??При вызове такого метода заметно страдает производительность.
??Необходимо знать о двухаргументной форме parseInt().
??Нужно помнить детали работы parseInt() при наличии двух аргументов.
??Значительно осложняется работа динамического компилятора.
??Сущность, являющаяся константой во время компиляции, представляется как выражение времени исполнения. Это означает, что константа не сможет использоваться в качестве значения в операторе switch.
??Вы получите исключение RuntimeException (но не исключение времени компиляции), если допустите опечатку в двоичном значении.
К счастью, после появления Java 7 мы можем поступить так:
int x = 0b1100110;
М
ы не утверждаем, что эта конструкция позволяет совершить что-то ранее невозможное. Но в таком случае не возникает ни одной из перечисленных выше проблем.
Если у вас будут причины для работы с двоичными файлами, то эта маленькая функция вам очень пригодится. Например, при выполнении низкоуровневой обработки байтов вы можете оперировать комбинациями битов как двоичными константами в операторах switch.
Еще одно небольшое, но полезное нововведение для представления групп битов или других длинных числовых представлений — применение нижних подчеркиваний в числах.
50 Часть 1. Разработка на Java 7
Нижние подчеркивания в числах
Вы, наверное, не сомневаетесь, что человеческий мозг принципиально отличается от компьютерного процессора. Характерным примером такого отличия является то, как наш мозг обрабатывает числа. Вообще, люди плохо умеют обращаться с длинными последовательностями чисел. Это — одна из причин, по которым появилась шестнадцатеричная система счисления, ведь наш разум лучше оперирует более короткими строками, сильнее насыщенными информацией, чем длинными последовательностями, каждый символ в которых сравнительно малоинформативен.
Так, нам будет проще работать с 1c372ba3, чем с 00011100001101110010101110100011, хотя процессор всегда будет иметь дело со второй формой. Один из способов, которым люди научились справляться с длинными последовательностями чисел, — разбиение их на части. Так, телефонный номер в США обычно имеет следующую форму: 404-555-0122.
ПРИМЕЧАНИЕ
Если любознательные читатели из Европы задумывались о том, почему номера американских телефонов в фильмах и книгах всегда начинаются с 555, поясним: номера в диапазоне 555-01xx специально зарезервированы для такого «художественного» использования, чтобы никто не получал телефонных звонков от зрителей, воспринимающих голливудское кино чересчур серьезно.
В других длинных последовательностях чисел применяются разделительные знаки, например:
??$100,000,000 (большие суммы денег в США);
??08-92-96 (номера отделений банков в Великобритании).
К сожалению, и запятая и дефис — слишком многозначные символы в сфере обработки чисел в программировании. Поэтому оба символа не подходят нам в качестве разделительных знаков. Вместо этого разработчики проекта «Монета» позаимствовали идею из языка ? ? ? ? ? ? ? ? - Ruby?и ввели в качестве разделительного знака нижнее подчеркивание (_). Обратите внимание: здесь показан всего лишь фрагмент удобного для чтения синтаксиса, применяемого во время компиляции. Компилятор извлекает из кода нижние подчеркивания и сохраняет обычные цифры.
Это означает, что вы можете записать 100_000_000 и, скорее всего, не перепутаете это число с 10_000_000, тогда как перепутать 100000000 с 10000000 очень легко. Рассмотрим пару примеров, как минимум один из них должен показаться вам знакомым:
long anotherLong = 2_147_483_648L;
int bitPattern = 0b0001_1100__0011_0111__0010_1011__1010_0011;
Обратите внимание, насколько проще стало читать значение, присвоенное anotherLong.
ВНИМАНИЕ
В Java по-прежнему допустимо использовать строчную букву l для обозначения типа long. Например, 1010100l. Обязательно используйте L в верхнем регистре, чтобы люди, занимающиеся поддержкой кода, не путали букву l и число 1. Запись 1010100L гораздо понятнее.
Глава 1. Введение в Java 7 51
Надеемся, что вы уже убедились в пользе этих дополнений при обработке целых чисел. Далее мы поговорим об усовершенствованной обработке исключений в Java 7.
1.3.3. Усовершенствованная
обработка исключений
Усовершенствования связаны с двумя основными изменениями: множественным catch (multicatch) и переброской неизменяемого исключения (final rethrow). Чтобы разобраться, чем полезны эти изменения, рассмотрим код на Java 6, который пытается найти, открыть файл конфигурации, произвести его синтаксический разбор и обработать несколько различных исключений (листинг 1.1).
Листинг 1.1. Обработка нескольких различных исключений в Java 6
public Configuration getConfig(String fileName) {
Configuration cfg = null;
try {
String fileText = getFile(fileName);
cfg = verifyConfig(parseConfig(fileText));
} catch (FileNotFoundException fnfx) {
System.err.println("Config file '" + fileName + "' is missing");
} catch (IOException e) {
System.err.println("Error while processing file '" + fileName + "'");
} catch (ConfigurationException e) {
System.err.println("Config file '" + fileName + "' is not consistent");
} catch (ParseException e) {
System.err.println("Config file '" + fileName + "' is malformed");
}
return cfg;
}
В этом методе возникает несколько различных ситуаций, приводящих к выбросу исключения:
??возможно, файл конфигурации не существует;
??вероятно, файл конфигурации исчезнет как раз в то время, когда вы считываете из него информацию;
??файл конфигурации может иметь неправильное синтаксическое оформление;
??в файле конфигурации может содержаться неверная информация.
Функционально эти исключительные ситуации относятся к двум разным группам: либо файл отсутствует или каким-то образом поврежден, либо файл присутствует и не содержит ошибок, но его не удается правильно получить (например, из-за ошибки оборудования или отказа сети).
Попробуем свести все варианты к этим двум случаям — тогда мы будем обрабатывать все исключения вида «файл отсутствует или каким-то образом поврежден» в одном условии catch (листинг 1.2). В Java 7 это возможно.
52 Часть 1. Разработка на Java 7
Листинг 1.2. Обработка нескольких различных исключений в Java 7
public Configuration getConfig(String fileName) {
Configuration cfg = null;
try {
String fileText = getFile(fileName);
cfg = verifyConfig(parseConfig(fileText));
} catch (FileNotFoundException|ParseException|ConfigurationException e) {
System.err.println("Config file '" + fileName +
"' is missing or malformed");
} catch (IOException iox) {
System.err.println("Error while processing file '" + fileName + "'");
}
return cfg;
}
Исключение e относится к типу, который не удается точно распознать во время компиляции. Это означает, что оно должно обрабатываться в блоке catch как относящееся к общему супертипу, охватывающему все типы исключений, к которым оно могло бы относиться (на практике это обычно бывает Exception или Throwable).
Еще один пример нового синтаксиса помогает разобраться с переброской исключений. Во многих случаях разработчику может потребоваться произвести какие-то манипуляции с полученным исключением до его переброски. Проблема заключается в том, что в более ранних версиях Java часто можно было встретить такой код:
try {
doSomethingWhichMightThrowIOException();
doSomethingElseWhichMightThrowSQLException();
} catch (Exception e) {
...
throw e;
}
Соответственно, вы вынуждены объявить сигнатуру исключения в этом коде как Exception — реальный динамический тип исключения оказывается поглощен.
Тем не менее несложно заметить, что исключение в этом коде может относиться только к типу IOException или SQLException, а если вы это видите, то и компилятор тоже видит. В синтаксисе Java 7 этот фрагмент изменится всего на одно слово:
try {
doSomethingWhichMightThrowIOException();
doSomethingElseWhichMightThrowSQLException();
} catch (final Exception e) {
...
throw e;
}
Поскольку здесь присутствует ключевое слово final, понятно, что фактически выбрасывается тип времени исполнения для найденного исключения — в данном
Глава 1. Введение в Java 7 53
случае это может быть лишь IOException или SQLException. Этот прием и называется переброской неизменяемого исключения (final rethrow). Она защищает нас от получения слишком общего типа исключения, который потом можно было бы перехватить лишь на очень высоком уровне, с помощью сильно обобщенной конструкции catch.
В предыдущем примере ключевое слово final является опциональным. Но практика показывает, что использовать его полезно — это помогает при корректировке новой семантики конструкций catch и rethrow.
Наряду с этими общими усовершенствованиями обработки исключений в Java 7 было улучшено и управление ресурсами. Об этом мы поговорим далее.
1.3.4. Использование ресурсов в блоке try
(try-with-resources)
Объяснить это изменение довольно легко, но оказалось, что такой механизм обладает скрытыми нюансами, из-за которых его реализация происходит значительно сложнее, чем ожидалось. Основная идея заключается в том, чтобы поместить ресурс (например, файл или тому подобную сущность) в область видимости блока таким образом, чтобы ресурс автоматически закрывался после выхода управления за пределы блока.
Это важное изменение по той простой причине, что практически никто не умеет вручную закрывать ресурсы на 100 % правильно. До недавнего времени даже в справочных руководствах от ? ? ? ? ? ? ? ? - Sun?этот процесс был описан с ошибками. Предложение, поданное в рамках проекта «Монета» и касающееся этого изменения, содержит ошеломляющее утверждение: якобы две трети случаев закрытия close() в JDK выполнены с ошибками!
К счастью, компилятор можно хорошо приспособить к созданию именно такого «педантичного» шаблонного кода, в котором человек часто допускает ошибки. Как раз такой подход и был выбран при реализации этого улучшения.
Действительно, новая конструкция очень помогает писать безошибочный код. Чтобы оценить, насколько она полезна, просто представьте себе, как бы вы написали в Java 6 блок кода, который считывает информацию из потока, идущего с URL (url), а потом записывает информацию в файл (out). Вот один из вариантов решения (листинг 1.3).
Листинг 1.3. Синтаксис для управления ресурсами в Java 6
54 Часть 1. Разработка на Java 7
А
у вас получилось похоже? Основной момент здесь заключается в том, что при обработке внешних ресурсов действует один из законов Мерфи: «Что угодно может сорваться в любой момент»:
??поток InputStream, из которого нужно считывать информацию, может не открыться по URL либо может закрыться неправильно;
??файл File, соответствующий потоку OutputStream, может не открыться (и в него нельзя будет записать информацию) либо может закрыться неправильно;
??может возникнуть проблема, обусловленная несколькими факторами.
Последняя проблема, доставляющая сильную головную боль, — очень сложно правильно разобраться с комбинацией нескольких исключений.
Именно по этой причине в основном предпочтение отдается новому синтаксису — в нем просто сложнее допустить ошибку. Компилятор не допускает таких ошибок, которые легко совершает любой разработчик, пытающийся написать код такого типа вручную.
Рассмотрим код ? ? ? ? ? ? ? ? ? ? -Java ? 7, осуществляющий такую же задачу, как и код из листинга 1.3. Как и выше, url — это объект URL (универсальный локатор ресурса), указывающий на сущность, которую вы хотите загрузить; file — это объект File, в котором вы хотите сохранить загружаемую информацию. Вот что получится в Java 7(листинг 1.4).
Листинг 1.4. Синтаксис Java 7 для управления ресурсами
try (OutputStream out = new FileOutputStream(file);
InputStream is = url.openStream() ) {
byte[] buf = new byte[4096];
int len;
while ((len = is.read(buf)) > 0) {
out.write(buf, 0, len);
}
}
Глава 1. Введение в Java 7 55
В этом простейшем примере показан синтаксис блока для автоматического управления — операция try с ресурсом в круглых скобках. Программисту, имеющему опыт работы с языком C#, эта конструкция может напомнить условие using. Концептуально это хороший отправной пункт для работы с данной новой функцией. Ресурсы используются в блоке и автоматически высвобождаются после того, как вы закончите работу с ними.
При работе с конструкцией try-with-resources нужно оставаться начеку, так как в некоторых случаях ресурс может остаться незакрытым. Например, следующий код не закроет FileInputStream правильно, если была допущена ошибка при создании ObjectInputStream из файла (someFile.bin).
try (ObjectInputStream in = new ObjectInputStream(new
FileInputStream("someFile.bin")) ) {
...
}
Предположим, что файл (someFile.bin) существует, но, возможно, это будет не файл ObjectInput. А файл другого формата может не открыться правильно. Следовательно, поток ObjectInputStream не будет создан, а поток FileInputStream не будет закрыт!
Наилучший способ гарантировать правильность работы try-with-resources — разбивать ресурсы на отдельные переменные.
try (FileInputStream fin = new FileInputStream("someFile.bin");
ObjectInputStream in = new ObjectInputStream(fin) ) {
...
}
Один из аспектов конструкции TWR — появление улучшенных стектрейсов и заблокированных исключений. До Java 7 информация об исключении могла быть поглощена при обработке ресурсов. Такой вариант не исключен и с TWR, поэтому стековые следы были усовершенствованы. Теперь вы можете просматривать в исключениях и информацию о типах, которая ранее просто терялась.
Например, рассмотрим следующий фрагмент кода, в котором нулевой InputStream возвращается из метода:
try(InputStream i = getNullStream()) {
i.available();
}
В результате получится улучшенный стектрейс, в котором мы увидим заблокированное исключение NullPointerException (сокращенно — NPE):
Exception in thread "main" java.lang.NullPointerException
at wgjd.ch01.ScratchSuprExcep.run(ScratchSuprExcep.java:23)
at wgjd.ch01.ScratchSuprExcep.main(ScratchSuprExcep.java:39)
Suppressed: java.lang.NullPointerException
at wgjd.ch01.ScratchSuprExcep.run(ScratchSuprExcep.java:24)
1 more
56 Часть 1. Разработка на Java 7
На уровне системы функция TWR реализуется с помощью нового интерфейса, называемого AutoCloseable. Класс должен реализовывать этот интерфейс, чтобы работать в рамках нового условия try конструкции TWR как ресурс. Многие классы платформы Java 7 были преобразованы так, чтобы могли реализовывать интерфейс AutoCloseable (в свою очередь, AutoCloseable был сделан суперинтерфейсом Closeable). Но необходимо учитывать, что эта новая технология задействована еще не во всех местах платформы. Эта функция, правда, была включена в состав JDBC 4.1.
В вашем собственном коде вам определенно следует использовать TWR всегда, когда возникает необходимость работать с ресурсами. Этот механизм позволит вам избежать ошибок при обработке исключений.
TWR И AUTOCLOSEABLE
Рекомендуем приступать к использованию конструкции try-with-resources, как только будет возможность. Тогда вы сможете легко избавиться от ошибок в вашей базе кода.
1.3.5. Ромбовидный синтаксис
В Java 7 есть и такое изменение, которое частично избавляет вас от набора кода при работе с обобщенными сущностями (дженериками). Одна из проблем при работе с дженериками заключается в том, что определение и настройка экземпляров бывают очень пространными. Допустим, у вас есть несколько пользователей, которых вы идентифицируете по userid (этот идентификатор представляет собой целое число). И каждый пользователь имеет одну или несколько таблиц поиска, специфичных именно для него. Как все это будет выглядеть в коде?
Map<Integer, Map<String, String>> usersLists =
new HashMap<Integer, Map<String, String>>();
Согласитесь, многовато текста, причем почти половина информации дублируется. Может быть, лучше написать что-то в таком роде:
Map<Integer, Map<String, String>> usersLists = new HashMap<>();
А
информацию о типах в правой части выражения пускай обрабатывает компилятор. Проект «Монета» предоставляет вам такую возможность. В Java 7 подобная сокращенная форма объявлений абсолютно допустима. Кроме того, такая форма обладает обратной совместимостью. Поэтому, если вам доведется пересматривать старый код, то можете сократить старые пространные объявления и перейти к использованию нового синтаксиса с выведением типов. Запись получится короче на несколько пикселов.
Необходимо отметить, что при работе с этой функцией компилятор использует новую форму выведения типов. В правой части выражения он выводит правильный тип для выражения, а не просто подставляет текст, определяющий полный тип.
Глава 1. Введение в Java 7 57
Такой синтаксис называется ромбовидным потому, что сокращенная информация о типе имеет форму ромба. Официальное название, фигурирующее в предложении, — «Усовершенствованное выведение типов при создании экземпляров обобщенных сущностей» (Improved Type Inference for Generic Instance Creation). Это чересчур длинное выражение, сокращаемое до аббревиатуры ITIGIC. Звучит довольно глупо, так что остановимся на термине «ромбовидный синтаксис».
ПОЧЕМУ ТАКОЙ СИНТАКСИС НАЗЫВАЕТСЯ РОМБОВИДНЫМ
Несомненно, новый ромбовидный синтаксис позволяет печатать меньше кода. Наконец, рассмотрим еще одну новую функцию, появившуюся в рамках проекта «Монета». Речь пойдет об удалении предупреждений, возникающих при использовании переменного количества аргументов.
1.3.6. Упрощенный вызов методов
с переменным количеством аргументов
Это одно из самых простых изменений. Оно удаляет предупреждение, касающееся информации о типе. Такие предупреждения возникают в очень специфичных случаях, когда переменное количество аргументов комбинируется с дженериками в сигнатуре метода.
Иными словами, если вы не имеете привычки писать код, принимающий в качестве аргументов переменное количество ссылок типа T, а потом осуществляете операцию, требующую сделать выборку из этих ссылок, то можете пропустить этот раздел и переходить к следующему. Если же фрагмент ниже напоминает что-то из вашего творчества, то читайте дальше.
public static <T> Collection<T> doSomething(T... entries) {
...
}
Итак, читаем дальше? Хорошо. Разберемся, в чем же проблема.
Вы, наверное, знаете, что метод с переменным количеством аргументов — это такой метод, который принимает переменное количество параметров (все эти параметры относятся к одному типу) в конце списка аргументов. Но вы, возможно, не знаете, как реализуются такие vararg-методы. Как правило, все находящиеся в конце списка переменные параметры помещаются в массив (автоматически создаваемый для вас компилятором) и передаются как единый параметр.
Все это, конечно, хорошо, но тут мы сталкиваемся с одним из признанных слабых мест дженериков Java — как правило, вы не можете создать массив элементов уже известного обобщенного типа. Например, следующий код не скомпилируется:
HashMap<String, String>[] arrayHm = new HashMap<>[2];
58 Часть 1. Разработка на Java 7
Нельзя создать массив указанного обобщенного типа. Вместо этого приходится сделать так:
HashMap<String, String>[] warnHm = new HashMap[2];
Выдается предупреждение, которое следует проигнорировать. Обратите внимание: вы можете определить тип warnHm как массив HashMap<String, String> — но просто не можете создать ни одного экземпляра такого типа. Приходится «наступить себе на горло» (или как минимум заблокировать предупреждение) и принудительно преобразовать экземпляр необработанного типа (представляющий собой массив HashMap) в warnHm.
Два этих феномена — во-первых, методы с переменным количеством аргументов, обрабатывающие сгенерированные компилятором массивы, и, во-вторых, массивы известных обобщенных типов, которые, однако, невозможно инстанцировать — вместе становятся очередной головной болью. Рассмотрим следующий код:
HashMap<String, String> hm1 = new HashMap<>();
HashMap<String, String> hm2 = new HashMap<>();
Collection<HashMap<String, String>> coll = doSomething(hm1, hm2);
Компилятор попытается создать массив, содержащий как hm1, так и hm2, но тип этого массива строго должен быть одним из запрещенных типов массивов. Сталкиваясь с такой дилеммой, компилятор жульничает и нарушает собственное правило о запрещенном массиве обобщенного типа. Он создает экземпляр массива, но при этом «ругается», выдавая невразумительное предупреждение вида «непроверенные или небезопасные операции».
С точки зрения системы типов тут все вполне правильно. Но несчастный разработчик всего-то хотел использовать штуку, которая казалась совершенно нормальным ? ? ? ? ? -? ? ? ? ? -? ? -API? -, а ему выдают какие-то грозные предупреждения по каким-то необъясненным причинам.
Куда деваются предупреждения в Java 7?
Рассматриваемая новая функция в Java 7 изменяет акцент в предупреждении. В конце концов, в конструкциях таких типов есть потенциал для нарушения безопасности типов, и кого-то об этом лучше предупредить. Но программисты, пользующиеся такими типами API, могут сделать с их помощью не так много. Код в doSomething() либо нарушает безопасность типов, либо не нарушает. В любом случае от пользователя API ничего не зависит.
Кому действительно важно получить такое предупреждение — так это товарищу, написавшему doSomething(), то есть производителю API, а не его потребителю. Туда и отправляется предупреждение. Оно попадает не туда, где используется API, а туда, где этот API был определен.
Раньше предупреждение инициировалось при компиляции кода, использовавшего данный API. Теперь же оно выдается в том случае, когда пишется API, обладающий потенциалом для подобного нарушения безопасности типов. Компилятор предупреждает программиста, реализующего API, — и обратить внимание на систему типов должен именно его разработчик.
Чтобы упростить жизнь и разработчикам API, Java 7 также предоставляет новый тип аннотаций: java.lang.SafeVarargs. Такая аннотация может применяться к методу
Глава 1. Введение в Java 7 59
API (или конструктору), который в противном случае выдал бы предупреждение рассмотренного выше вида. Аннотируя метод с помощью @SafeVarargs, разработчик, в сущности, гарантирует, что этот метод не будет совершать никаких небезопасных операций. Если это произойдет, то компилятор заблокирует предупреждение.
Изменения в системе типов
Как много слов пришлось написать, чтобы рассказать о совсем маленьком изменении! Итак, возможность переместить предупреждение из одного места в другое — это, конечно, не революционное нововведение в языке. Но рассмотренный пример помогает проиллюстрировать один очень важный момент. Выше в этой главе мы упоминали, что в рамках проекта «Монета» разработчикам рекомендуется не трогать систему типов, предлагая изменения. А на этом примере видно, сколько всего требуется сделать, чтобы понять, как именно взаимодействуют различные компоненты системы типов и как изменятся эти взаимодействия вслед за внесением изменений в структуру языка. Данное изменение даже не назовешь особенно сложным — в отличие от тех, о которых нам еще предстоит поговорить. Изменения, рассмотренные ниже, намного более сложны и потенциально могут разветвляться на десятки несхожих ситуаций, различия между которыми, однако, не такие явные.
Этот последний пример демонстрирует, насколько заковыристым может быть эффект от самых небольших изменений. Хотя здесь мы обсудили в основном мелкие синтаксические изменения, они могут значительно улучшить ваш код. Действительно, мал золотник, да дорог. Как только вы начнете работать с этими изменениями, вы убедитесь, насколько они полезны в создаваемых программах.
1.4. Резюме
Вносить изменения в язык непросто. Новую функцию всегда легче реализовать в виде библиотеки (если это, конечно, возможно — некоторые функции нереализуемы без внесения изменений в язык). Связанные с этим сложности вынуждают разработчиков языка вносить мелкие и сравнительно консервативные изменения, чем им, возможно, хотелось бы.
Теперь перейдем к более обширным изменениям, появившимся в этом релизе. Для начала рассмотрим, какие из основных библиотек поменялись в Java 7. Следующая большая тема — это библиотеки ввода-вывода, которые были во многом пересмотрены. Вам совсем не помешают знания о том, как ввод-вывод был организован в более ранних версиях Java, так как классы Java 7 (иногда называемые NIO.2) построены на базе уже имеющегося фреймворка.
Если вы хотите изучить дополнительные примеры синтаксиса TWR в действии либо узнать о новых высокопроизводительных классах ввода-вывода, то переворачивайте страницу — обо всем этом рассказано в следующей главе.
2
Новый
ввод-вывод
В этой главе:
??новые API ввода-вывода в Java 7 (также называемые NIO.2);
??Path — новая основа для файлового ввода-вывода и ввода-вывода каталогов;
??вспомогательный класс Files и его различные вспомогательные методы;
??решение типичных практических сложностей с вводом-выводом;
??введение в асинхронный ввод-вывод.
Одно из самых значительных изменений API в языке Java — крупные обновления в наборе API для ввода-вывода. Новый набор называется «Обновленный ввод-вывод» или NIO.2 (описан в запросе на спецификацию JSR-203). Именно ему посвящена основная часть данной главы. NIO.2 — это набор новых классов и методов, большинство из которых относится к пакету java.nio.
??Этот пакет является полнофункциональной заменой java.io.File. Пакет предназначен для написания кода, взаимодействующего с файловой системой.
??Он содержит новые асинхронные классы, с помощью которых вы сможете выполнять файловые и сетевые операции ввода-вывода в фоновом потоке. При этом не придется вручную конфигурировать пулы потоков и другие низкоуровневые конструкции, предназначенные для параллельной обработки.
??Пакет упрощает написание кода с использованием сокетов и каналов, так как появляется новая конструкция Network-Channel.
Расмотрим пример практического использования. Предположим, начальник поручил вам написать процедуру Java, которая просматривает все каталоги на рабочем сервере и находит все файлы свойств, содержащие заданный набор привилегий на чтение/запись и владение файлом. В Java 6 (и ниже) решить такую задачу практически невозможно в силу нескольких причин:
??на уровне классов и методов отсутствует прямая поддержка навигации по дереву каталогов;
??нет способа поиска символьных ссылок и манипулирования ими;
??отсутствует простая операция для считывания атрибутов файла (таких как readable, writable или executable).
Новый API Java 7 NIO.2 значительно упрощает решение этой программной задачи, так как непосредственно поддерживает навигацию по дереву каталогов (Files.
Глава 2. Новый ввод-вывод
61
walkFileTree(), см. подраздел 2.3.1), символьные ссылки1 (Files.isSymbolicLink(), см. листинг 2.4), а также простые однострочные операции для считывания атрибутов файлов (Files.readAttributes(), см. подраздел 2.4.3).
Кроме того, начальник требует, чтобы эти файлы свойств считывались, не нарушая основного рабочего потока программы. Вы знаете, что один из файлов свойств имеет размер не менее 1 М байт; считывание этого файла наверняка помешает основному рабочему потоку программы! В Java 5/6 пришлось бы использовать классы из пакета java.util.concurrent для создания пулов потоков и рабочих очередей, чтобы считывание этого файла происходило в отдельном фоновом потоке. Как будет показано в главе 4, современная параллельная обработка в Java остается довольно сложной, разброс возможных ошибок очень велик. Но в Java 7 с помощью API NIO.2 вы сможете считать большой файл в фоновом режиме, не указывая собственных рабочих потоков и очередей, пользуясь новым AsynchronousFileChannel (см. раздел 2.5). Уф!
Эти новые API — не панацея (хотя функции очень симпатичные), тем не менее они вам очень пригодятся, учитывая, каковы основные тенденции в нашем деле.
Во-первых, все активнее исследуются альтернативные методы хранения данных, особенно в случаях с нереляционными и очень крупными наборами данных. Это означает, что в ближайшем будущем предстоит много работать со считыванием и записью крупных файлов (например, большие файлы отчетов с сервиса микроблогов). NIO.2 позволяет считывать и записывать крупные файлы в эффективном асинхронном режиме, опираясь при этом на базовые функции операционной системы.
Вторая тенденция — распространение многоядерных процессоров, открывающих возможности для по-настоящему параллельного (а значит, быстрого) ввода-вывода. Параллелизм — искусство, которое не так просто освоить2, но NIO.2 значительно облегчает эту задачу, предлагая простые абстракции для использования многопоточного доступа к файлам и сокетам. Даже если вы не используете эти функции непосредственно, они все равно будут все сильнее влиять на вашу практику программирования по мере их распространения в IDE, серверах приложений и в популярных фреймворках.
Это всего несколько примеров, демонстрирующих, чем может быть полезен NIO.2. Если у вас сложилось впечатление, что NIO.2 — это механизм, помогающий решить некоторые типичные проблемы, с которыми вы сталкиваетесь в ходе разработки, то эта глава — для вас! Если описанные ситуации вам не встречались, то всегда можно вернуться к разделам этой главы, описывающим задачи программирования ввода-вывода на Java.
Текущая глава позволяет в достаточной мере познакомиться с возможностями ввода-вывода в Java 7, чтобы приступить к написанию кода на основе NIO.2 и уверенно исследовать новые API. Вам поможет и то, что некоторые из рассматриваемых здесь функций уже затрагивались в первой главе. Это еще раз доказывает, что Java 7 действительно умеет пользоваться встроенными в него механизмами!
В главе 4 рассмотрены те сложные нюансы, с которыми может столкнуться программист при реализации параллелизма.
62 Часть 1. Разработка на Java 7
СОВЕТ
Комбинация конструкции try-with-resources (см. главу 1) и новых API из NIO.2 обеспечивает исключительно надежное программирование ввода-вывода — пожалуй, впервые в истории Java!
Полагаем, что вы, скорее всего, планируете воспользоваться новыми возможностями файлового ввода-вывода. Поэтому мы рассмотрим эту тему очень подробно. Сначала мы поговорим о новой абстракции файловой системы — Path, а также о классах, поддерживающих эту абстракцию. Опираясь на знания о Path, мы обсудим обычные операции, осуществляемые в файловой системе, такие как перемещение и копирование файлов.
Кроме того, мы обсудим асинхронный ввод-вывод и рассмотрим пример, основанный на свойствах файловой системы. Наконец, мы поговорим о взаимопроникновении функционала Socket и Channel, а также о значении этих изменений для разработчиков сетевых приложений. Но начнем с того, как появился NIO.2.
2.1. История ввода-вывода в Java
Чтобы в полной мере оценить структуру API NIO.2 (и понять, как с ними нужно работать), основательный Java-разработчик должен знать историю ввода-вывода в Java. Но мы отлично понимаем, что вам уже не терпится перейти к коду! Если совсем не терпится — можете переходить к разделу 2.2.
Если какие-то примеры использования API покажутся вам особенно красивыми, а другие, возможно, немного странными, то этот раздел поможет вам взглянуть на NIO.2 с точки зрения создателей API. Это третья крупная реализация ввода-вывода в Java. Поэтому, чтобы понять, как появился NIO.2, обратимся к истории поддержки ввода-вывода в Java.
Одна из причин огромной популярности Java заключается в обширной библиотечной поддержке. В языке предоставляются мощные и лаконичные API, позволяющие решать разнообразные задачи при программировании. Но опытным Java-разработчикам известно, что есть несколько областей, которые были реализованы в ранних версиях Java практически на пещерном уровне. Одной из основных проблем для разработчиков долгое время были API для ввода-вывода (I/O).
2.1.1. Java 1.0–1.3
В самых ранних версиях Java (1.0–3.0) отсутствует полномасштабная поддержка ввода-вывода. В частности, разработчики сталкивались со следующими проблемами при создании приложений, требующих поддержки ввода-вывода.
??Отсутствовали концепции буферов или абстракций каналов для данных. Поэтому разработчикам приходилось много и кропотливо заниматься низкоуровневым программированием.
??Операции ввода-вывода часто блокировались, что ограничивало масштабируемость.
??Существовала лишь ограниченная поддержка различных символьных кодировок. Поэтому имелось множество запрограммированных вручную решений для поддержки определенных типов оборудования.
Глава 2. Новый ввод-вывод 63
Язык программирования Perl — бесспорный лидер в области поддержки регулярных выражений. На самом деле его дизайн и реализация настолько хороши, что несколько языков программирования (в том числе Java) во многом скопировали синтаксис и семантику Perl. Если вас интересует история этого языка, то любую информацию о нем можно прочитать на сайте http://www.perl.org/.
??Отсутствовала поддержка регулярных выражений, что осложняло манипуляции с данными.
Вообще, в Java отсутствовала поддержка неблокирующего ввода-вывода. Поэтому разработчикам с большим трудом удавалось создавать масштабируемые решения для ввода-вывода. Мы считаем, что эти неудобства частично объясняют, почему язык Java почти не использовался в разработках для серверной стороны до выхода Java 1.4.
2.1.2. Java 1.4 и неблокирующий ввод-вывод
Для того чтобы решить эти проблемы, Java приступила к реализации поддержки неблокирующего ввода-вывода, а также других функций, позволяющих разработчикам создавать более быстрые и надежные решения для реализации ввода-вывода. В этой области в разное время были достигнуты два крупных улучшения:
??в рамках Java 1.4 был реализован неблокирующий ввод-вывод;
??в Java 7 механизм неблокирующего вывода был коренным образом переработан.
На основании запроса на спецификацию JSR-51 неблокирующий ввод-вывод (NIO) был добавлен в Java в 2002 году, когда вышла версия 1.4. На этом этапе добавился следующий обширный набор функций, благодаря которым Java превратился в привлекательный язык для серверной разработки:
??абстрактные уровни (уровень буфера и уровень канала) для операций ввода-вывода;
??возможность кодировать и декодировать наборы символов;
??интерфейс, позволяющий ассоциировать файлы с данными, хранящимися в памяти;
??новая библиотека регулярных выражений, основанная на популярной реализации на языке Perl.
PERL — КОРОЛЬ РЕГУЛЯРНЫХ ВЫРАЖЕНИЙ
Неблокирующий ввод-вывод был настоящим прорывом, но Java-разработчики по-прежнему сталкивались со сложностями при программировании ввода-вывода. В частности, поддержка обработки файлов и каталогов в файловой системе оставляла желать лучшего. На тот момент класс java.io.File содержал несколько досадных недоработок:
??отсутствовала непротиворечивая обработка имен файлов на разных платформах1;
1 Некоторые критики Java могли бы сказать, что именно в этой области язык Java нарушает известный принцип «Написать однажды, использовать везде».
64 Часть 1. Разработка на Java 7
??не удавалось создать унифицированную модель работы с атрибутами файлов (например, при моделировании доступа для чтения/для внесения изменений);
??возникали сложности с обходом каталогов;
??не удавалось использовать функции, специфичные для платформы или операционной системы1;
??в файловых системах не поддерживались неблокирующие операции2.
конец